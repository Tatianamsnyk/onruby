# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/oga/all/oga.rbi
#
# oga-2.14
module Oga
  def self.parse_html(html, options = nil); end
  def self.parse_xml(xml, options = nil); end
  def self.sax_parse_html(handler, html, options = nil); end
  def self.sax_parse_xml(handler, xml, options = nil); end
end
class Oga::LRU
  def [](key); end
  def []=(key, value); end
  def clear; end
  def get_or_set(key); end
  def initialize(maximum = nil); end
  def key?(key); end
  def keys; end
  def length; end
  def maximum; end
  def maximum=(value); end
  def resize; end
  def size; end
  def synchronize; end
end
module Oga::EntityDecoder
  def self.decode(input, html = nil); end
  def self.try_decode(input, html = nil); end
end
class Oga::Blacklist
  def +(other); end
  def allow?(name); end
  def each; end
  def initialize(names); end
  def names; end
end
class Oga::Whitelist < Oga::Blacklist
  def allow?(name); end
  def to_blacklist; end
end
module Oga::XML
end
class Oga::XML::Lexer
  def add_element(name); end
  def add_token(type, value = nil); end
  def advance(&block); end
  def advance_line(amount = nil); end
  def advance_native(arg0); end
  def before_html_element_name(name); end
  def current_element; end
  def html?; end
  def html_script?; end
  def html_style?; end
  def initialize(data, options = nil); end
  def lex; end
  def on_attribute(value); end
  def on_attribute_ns(value); end
  def on_cdata_body(value); end
  def on_cdata_end; end
  def on_cdata_start; end
  def on_comment_body(value); end
  def on_comment_end; end
  def on_comment_start; end
  def on_doctype_end; end
  def on_doctype_inline(value); end
  def on_doctype_name(value); end
  def on_doctype_start; end
  def on_doctype_type(value); end
  def on_element_end(name = nil); end
  def on_element_name(name); end
  def on_element_ns(namespace); end
  def on_element_open_end; end
  def on_proc_ins_body(value); end
  def on_proc_ins_end; end
  def on_proc_ins_name(value); end
  def on_proc_ins_start; end
  def on_string_body(value); end
  def on_string_dquote; end
  def on_string_squote; end
  def on_text(value); end
  def on_xml_decl_end; end
  def on_xml_decl_start; end
  def read_data; end
  def reset_native; end
  def strict?; end
end
class Oga::XML::Parser < LL::Driver
  def _rule_0(val); end
  def _rule_1(val); end
  def _rule_10(val); end
  def _rule_11(val); end
  def _rule_12(val); end
  def _rule_13(val); end
  def _rule_14(val); end
  def _rule_15(val); end
  def _rule_16(val); end
  def _rule_17(val); end
  def _rule_18(val); end
  def _rule_19(val); end
  def _rule_2(val); end
  def _rule_20(val); end
  def _rule_21(val); end
  def _rule_22(val); end
  def _rule_23(val); end
  def _rule_24(val); end
  def _rule_25(val); end
  def _rule_26(val); end
  def _rule_27(val); end
  def _rule_28(val); end
  def _rule_29(val); end
  def _rule_3(val); end
  def _rule_30(val); end
  def _rule_31(val); end
  def _rule_32(val); end
  def _rule_33(val); end
  def _rule_34(val); end
  def _rule_35(val); end
  def _rule_36(val); end
  def _rule_37(val); end
  def _rule_38(val); end
  def _rule_39(val); end
  def _rule_4(val); end
  def _rule_40(val); end
  def _rule_41(val); end
  def _rule_42(val); end
  def _rule_5(val); end
  def _rule_6(val); end
  def _rule_7(val); end
  def _rule_8(val); end
  def _rule_9(val); end
  def after_element(element); end
  def each_token; end
  def initialize(data, options = nil); end
  def on_attribute(name, ns_name = nil, value = nil); end
  def on_attributes(attrs); end
  def on_cdata(text = nil); end
  def on_comment(text = nil); end
  def on_doctype(options = nil); end
  def on_document(children = nil); end
  def on_element(namespace, name, attributes = nil); end
  def on_element_children(element, children = nil); end
  def on_proc_ins(name, text = nil); end
  def on_text(text); end
  def on_xml_decl(attributes = nil); end
  def parser_error(stack_type, stack_value, token_type, token_value); end
end
module Oga::XML::ToXML
  def to_xml; end
end
module Oga::XML::Entities
  def self.decode(input, mapping = nil); end
  def self.encode(input, mapping = nil); end
  def self.encode_attribute(input); end
  def self.pack_string(input, base); end
end
module Oga::XML::Querying
  def at_css(*args); end
  def at_xpath(*args); end
  def css(expression); end
  def xpath(expression, variables = nil); end
end
module Oga::XML::Traversal
  def each_node; end
end
module Oga::XML::ExpandedName
  def expanded_name; end
end
class Oga::XML::Node
  def after(other); end
  def before(other); end
  def children; end
  def children=(nodes); end
  def each_ancestor; end
  def html?; end
  def initialize(options = nil); end
  def next; end
  def next=(arg0); end
  def next_element; end
  def node_set; end
  def node_set=(set); end
  def parent; end
  def previous; end
  def previous=(arg0); end
  def previous_element; end
  def remove; end
  def replace(other); end
  def root_node; end
  def xml?; end
  include Oga::XML::ToXML
  include Oga::XML::Traversal
end
class Oga::XML::Document
  def children; end
  def children=(nodes); end
  def doctype; end
  def doctype=(arg0); end
  def html?; end
  def initialize(options = nil); end
  def inspect; end
  def literal_html_name?; end
  def root_node; end
  def type; end
  def xml_declaration; end
  def xml_declaration=(arg0); end
  include Oga::XML::Querying
  include Oga::XML::ToXML
  include Oga::XML::Traversal
end
class Oga::XML::CharacterNode < Oga::XML::Node
  def initialize(options = nil); end
  def inspect; end
  def text; end
  def text=(arg0); end
end
class Oga::XML::Text < Oga::XML::CharacterNode
  def decode_entities?; end
  def initialize(*args); end
  def inside_literal_html?; end
  def text; end
  def text=(value); end
end
class Oga::XML::Comment < Oga::XML::CharacterNode
end
class Oga::XML::Cdata < Oga::XML::CharacterNode
end
class Oga::XML::ProcessingInstruction < Oga::XML::CharacterNode
  def initialize(options = nil); end
  def inspect; end
  def name; end
  def name=(arg0); end
end
class Oga::XML::XmlDeclaration < Oga::XML::ProcessingInstruction
  def encoding; end
  def encoding=(arg0); end
  def initialize(options = nil); end
  def inspect; end
  def standalone; end
  def standalone=(arg0); end
  def version; end
  def version=(arg0); end
end
class Oga::XML::Doctype < Oga::XML::Node
  def initialize(options = nil); end
  def inline_rules; end
  def inline_rules=(arg0); end
  def inspect; end
  def name; end
  def name=(arg0); end
  def public_id; end
  def public_id=(arg0); end
  def system_id; end
  def system_id=(arg0); end
  def type; end
  def type=(arg0); end
end
class Oga::XML::Namespace
  def ==(other); end
  def initialize(options = nil); end
  def inspect; end
  def name; end
  def name=(arg0); end
  def to_s; end
  def uri; end
  def uri=(arg0); end
end
class Oga::XML::Attribute
  def each_ancestor; end
  def element; end
  def element=(arg0); end
  def html?; end
  def initialize(options = nil); end
  def inspect; end
  def name; end
  def name=(arg0); end
  def namespace; end
  def namespace_name; end
  def namespace_name=(arg0); end
  def parent; end
  def text; end
  def to_s; end
  def value; end
  def value=(value); end
  include Oga::XML::ExpandedName
  include Oga::XML::ToXML
end
class Oga::XML::Element < Oga::XML::Node
  def [](name); end
  def []=(name, value); end
  def add_attribute(attribute); end
  def attr(name); end
  def attribute(name); end
  def attribute_matches?(attr, ns, name); end
  def attributes; end
  def attributes=(arg0); end
  def available_namespaces; end
  def default_namespace?; end
  def flush_namespaces_cache; end
  def get(name); end
  def initialize(options = nil); end
  def inner_text; end
  def inner_text=(text); end
  def inspect; end
  def link_attributes; end
  def literal_html_name?; end
  def name; end
  def name=(arg0); end
  def namespace; end
  def namespace_name; end
  def namespace_name=(name); end
  def namespaces; end
  def namespaces=(arg0); end
  def register_namespace(name, uri, flush = nil); end
  def register_namespaces_from_attributes; end
  def self_closing?; end
  def set(name, value); end
  def split_name(name); end
  def text; end
  def text_nodes; end
  def unset(name); end
  include Oga::XML::ExpandedName
  include Oga::XML::Querying
end
class Oga::XML::NodeSet
  def +(other); end
  def <<(node); end
  def ==(other); end
  def [](index); end
  def attr(name); end
  def attribute(name); end
  def concat(other); end
  def count; end
  def delete(node); end
  def each; end
  def empty?; end
  def equal_nodes?(nodes); end
  def exists?(node); end
  def index(node); end
  def initialize(nodes = nil, owner = nil); end
  def insert(index, node); end
  def inspect; end
  def last; end
  def length; end
  def mark_existing(node); end
  def owner; end
  def owner=(arg0); end
  def pop; end
  def push(node); end
  def remove; end
  def remove_ownership(node); end
  def shift; end
  def size; end
  def take_ownership(node, index); end
  def text; end
  def to_a; end
  def unmark_existing(node); end
  def unshift(node); end
  include Enumerable
end
class Oga::XML::Generator
  def after_element(element, output); end
  def html_void_element?(element); end
  def initialize(root); end
  def on_attribute(attr, output); end
  def on_cdata(node, output); end
  def on_comment(node, output); end
  def on_doctype(node, output); end
  def on_document(doc, output); end
  def on_element(element, output); end
  def on_processing_instruction(node, output); end
  def on_text(node, output); end
  def on_xml_declaration(node, output); end
  def self_closing?(element); end
  def to_xml; end
end
class Oga::XML::SaxParser < Oga::XML::Parser
  def after_element(namespace_with_name); end
  def initialize(handler, *args); end
  def inside_literal_html?; end
  def on_attribute(name, ns = nil, value = nil); end
  def on_attributes(attrs); end
  def on_cdata(*args); end
  def on_comment(*args); end
  def on_doctype(*args); end
  def on_document(*args); end
  def on_element(namespace, name, attrs = nil); end
  def on_element_children(*args); end
  def on_proc_ins(*args); end
  def on_text(text); end
  def on_xml_decl(*args); end
  def run_callback(method, *args); end
end
class Oga::XML::PullParser < Oga::XML::Parser
  def after_element(*args); end
  def initialize(*args); end
  def nesting; end
  def node; end
  def on(type, nesting = nil); end
  def on_cdata(*args); end
  def on_comment(*args); end
  def on_doctype(*args); end
  def on_document(*args); end
  def on_element(*args); end
  def on_element_children(*args); end
  def on_proc_ins(*args); end
  def on_text(*args); end
  def on_xml_decl(*args); end
  def parse(&block); end
end
module Oga::HTML
end
class Oga::HTML::Parser < Oga::XML::Parser
  def initialize(data, options = nil); end
end
class Oga::HTML::SaxParser < Oga::XML::SaxParser
  def initialize(handler, data, options = nil); end
end
module Oga::HTML::Entities
  def self.decode(input); end
end
module Oga::Ruby
end
class Oga::Ruby::Node < BasicObject
  def add_block(*args); end
  def and(other); end
  def assign(other); end
  def else; end
  def eq(other); end
  def followed_by(other = nil); end
  def if_false; end
  def if_true; end
  def initialize(type, children = nil); end
  def inspect; end
  def is_a?(klass); end
  def method_missing(name, *args); end
  def not; end
  def or(other); end
  def to_a; end
  def to_array; end
  def to_ary; end
  def type; end
  def while_true; end
  def wrap; end
end
class Oga::Ruby::Generator
  def on_and(ast); end
  def on_assign(ast); end
  def on_begin(ast); end
  def on_block(ast); end
  def on_eq(ast); end
  def on_followed_by(ast); end
  def on_if(ast); end
  def on_lit(ast); end
  def on_massign(ast); end
  def on_or(ast); end
  def on_range(ast); end
  def on_send(ast); end
  def on_string(ast); end
  def on_symbol(ast); end
  def on_while(ast); end
  def process(ast); end
end
module Oga::XPath
end
class Oga::XPath::Lexer
  def add_token(type, value = nil); end
  def advance(&block); end
  def emit(type, start, stop); end
  def initialize(data); end
  def lex; end
  def self._xpath_lexer_eof_trans; end
  def self._xpath_lexer_eof_trans=(arg0); end
  def self._xpath_lexer_from_state_actions; end
  def self._xpath_lexer_from_state_actions=(arg0); end
  def self._xpath_lexer_index_offsets; end
  def self._xpath_lexer_index_offsets=(arg0); end
  def self._xpath_lexer_indicies; end
  def self._xpath_lexer_indicies=(arg0); end
  def self._xpath_lexer_key_spans; end
  def self._xpath_lexer_key_spans=(arg0); end
  def self._xpath_lexer_to_state_actions; end
  def self._xpath_lexer_to_state_actions=(arg0); end
  def self._xpath_lexer_trans_actions; end
  def self._xpath_lexer_trans_actions=(arg0); end
  def self._xpath_lexer_trans_keys; end
  def self._xpath_lexer_trans_keys=(arg0); end
  def self._xpath_lexer_trans_targs; end
  def self._xpath_lexer_trans_targs=(arg0); end
  def self.xpath_lexer_en_main; end
  def self.xpath_lexer_en_main=(arg0); end
  def self.xpath_lexer_error; end
  def self.xpath_lexer_error=(arg0); end
  def self.xpath_lexer_first_final; end
  def self.xpath_lexer_first_final=(arg0); end
  def self.xpath_lexer_start; end
  def self.xpath_lexer_start=(arg0); end
  def slice_input(start, stop); end
end
class Oga::XPath::Parser < LL::Driver
  def _rule_0(val); end
  def _rule_1(val); end
  def _rule_10(val); end
  def _rule_11(val); end
  def _rule_12(val); end
  def _rule_13(val); end
  def _rule_14(val); end
  def _rule_15(val); end
  def _rule_16(val); end
  def _rule_17(val); end
  def _rule_18(val); end
  def _rule_19(val); end
  def _rule_2(val); end
  def _rule_20(val); end
  def _rule_21(val); end
  def _rule_22(val); end
  def _rule_23(val); end
  def _rule_24(val); end
  def _rule_25(val); end
  def _rule_26(val); end
  def _rule_27(val); end
  def _rule_28(val); end
  def _rule_29(val); end
  def _rule_3(val); end
  def _rule_30(val); end
  def _rule_31(val); end
  def _rule_32(val); end
  def _rule_33(val); end
  def _rule_34(val); end
  def _rule_35(val); end
  def _rule_36(val); end
  def _rule_37(val); end
  def _rule_38(val); end
  def _rule_39(val); end
  def _rule_4(val); end
  def _rule_40(val); end
  def _rule_41(val); end
  def _rule_42(val); end
  def _rule_43(val); end
  def _rule_44(val); end
  def _rule_45(val); end
  def _rule_46(val); end
  def _rule_47(val); end
  def _rule_48(val); end
  def _rule_49(val); end
  def _rule_5(val); end
  def _rule_50(val); end
  def _rule_51(val); end
  def _rule_52(val); end
  def _rule_53(val); end
  def _rule_54(val); end
  def _rule_55(val); end
  def _rule_56(val); end
  def _rule_57(val); end
  def _rule_58(val); end
  def _rule_59(val); end
  def _rule_6(val); end
  def _rule_60(val); end
  def _rule_61(val); end
  def _rule_62(val); end
  def _rule_63(val); end
  def _rule_64(val); end
  def _rule_65(val); end
  def _rule_66(val); end
  def _rule_67(val); end
  def _rule_68(val); end
  def _rule_69(val); end
  def _rule_7(val); end
  def _rule_8(val); end
  def _rule_9(val); end
  def combine_operators(val); end
  def combine_optional_operator(val); end
  def each_token; end
  def initialize(data); end
  def s(type, *children); end
  def self.parse_with_cache(data); end
end
class Oga::XPath::Context
  def evaluate(string); end
end
class Oga::XPath::Compiler
  def argument_or_first_node(input, arg = nil); end
  def attribute_or_node(node); end
  def break; end
  def catch_message(name); end
  def compile(ast); end
  def document_or_node(node); end
  def element_or_attribute(node); end
  def ensure_element_or_attribute(input); end
  def false; end
  def has_call_node?(ast, name); end
  def initialize; end
  def literal(value); end
  def mass_assign(vars, value); end
  def match_first_node(ast, input); end
  def match_name_and_namespace(ast, input); end
  def matched_literal; end
  def nil; end
  def number?(ast); end
  def on_absolute_path(ast, input, &block); end
  def on_add(ast, input, &block); end
  def on_and(ast, input, &block); end
  def on_axis(ast, input, &block); end
  def on_axis_ancestor(ast, input); end
  def on_axis_ancestor_or_self(ast, input); end
  def on_axis_attribute(ast, input); end
  def on_axis_child(ast, input); end
  def on_axis_descendant(ast, input); end
  def on_axis_descendant_or_self(ast, input); end
  def on_axis_following(ast, input); end
  def on_axis_following_sibling(ast, input); end
  def on_axis_namespace(ast, input); end
  def on_axis_parent(ast, input); end
  def on_axis_preceding(ast, input); end
  def on_axis_preceding_sibling(ast, input); end
  def on_axis_self(ast, input); end
  def on_call(ast, input, &block); end
  def on_call_boolean(input, arg); end
  def on_call_ceiling(input, arg); end
  def on_call_concat(input, *args); end
  def on_call_contains(input, haystack, needle); end
  def on_call_count(input, arg); end
  def on_call_false(*arg0); end
  def on_call_floor(input, arg); end
  def on_call_id(input, arg); end
  def on_call_lang(input, arg); end
  def on_call_last(*arg0); end
  def on_call_local_name(input, arg = nil); end
  def on_call_name(input, arg = nil); end
  def on_call_namespace_uri(input, arg = nil); end
  def on_call_normalize_space(input, arg = nil); end
  def on_call_not(input, arg); end
  def on_call_number(input, arg = nil); end
  def on_call_position(*arg0); end
  def on_call_round(input, arg); end
  def on_call_starts_with(input, haystack, needle); end
  def on_call_string(input, arg = nil); end
  def on_call_string_length(input, arg = nil); end
  def on_call_substring(input, haystack, start, length = nil); end
  def on_call_substring_after(input, haystack, needle); end
  def on_call_substring_before(input, haystack, needle); end
  def on_call_sum(input, arg); end
  def on_call_translate(input, source, find, replace); end
  def on_call_true(*arg0); end
  def on_div(ast, input, &block); end
  def on_eq(ast, input, &block); end
  def on_float(ast, *arg1); end
  def on_gt(ast, input, &block); end
  def on_gte(ast, input, &block); end
  def on_int(ast, *arg1); end
  def on_lt(ast, input, &block); end
  def on_lte(ast, input, &block); end
  def on_mod(ast, input, &block); end
  def on_mul(ast, input, &block); end
  def on_neq(ast, input, &block); end
  def on_or(ast, input, &block); end
  def on_pipe(ast, input, &block); end
  def on_predicate(ast, input, &block); end
  def on_predicate_direct(input, test, predicate); end
  def on_predicate_index(input, test, predicate); end
  def on_predicate_temporary(input, test, predicate); end
  def on_string(ast, *arg1); end
  def on_sub(ast, input, &block); end
  def on_test(ast, input); end
  def on_type_test(ast, input, &block); end
  def on_type_test_comment(input); end
  def on_type_test_node(input); end
  def on_type_test_processing_instruction(input); end
  def on_type_test_text(input); end
  def on_var(ast, *arg1); end
  def operator(ast, input, optimize_first = nil); end
  def original_input_literal; end
  def predicate_index; end
  def predicate_nodeset; end
  def process(ast, input, &block); end
  def process_following_or_yield(following, matched, &block); end
  def raise_message(klass, message); end
  def range(start, stop); end
  def reset; end
  def return_nodeset?(ast); end
  def self.compile_with_cache(ast); end
  def send_message(name, *args); end
  def string(value); end
  def string?(ast); end
  def symbol(value); end
  def throw_message(name, *args); end
  def to_int(ast); end
  def true; end
  def try_match_first_node(ast, input, optimize_first = nil); end
  def unique_literal(name); end
  def variables_literal; end
end
module Oga::XPath::Conversion
  def self.boolean?(value); end
  def self.first_node_text(set); end
  def self.to_boolean(value); end
  def self.to_compatible_types(left, right); end
  def self.to_float(value); end
  def self.to_string(value); end
end
module Oga::CSS
end
class Oga::CSS::Lexer
  def add_token(type, value = nil); end
  def advance(&block); end
  def emit(type, start, stop); end
  def initialize(data); end
  def lex; end
  def self._css_lexer_eof_trans; end
  def self._css_lexer_eof_trans=(arg0); end
  def self._css_lexer_from_state_actions; end
  def self._css_lexer_from_state_actions=(arg0); end
  def self._css_lexer_index_offsets; end
  def self._css_lexer_index_offsets=(arg0); end
  def self._css_lexer_indicies; end
  def self._css_lexer_indicies=(arg0); end
  def self._css_lexer_key_spans; end
  def self._css_lexer_key_spans=(arg0); end
  def self._css_lexer_to_state_actions; end
  def self._css_lexer_to_state_actions=(arg0); end
  def self._css_lexer_trans_actions; end
  def self._css_lexer_trans_actions=(arg0); end
  def self._css_lexer_trans_keys; end
  def self._css_lexer_trans_keys=(arg0); end
  def self._css_lexer_trans_targs; end
  def self._css_lexer_trans_targs=(arg0); end
  def self.css_lexer_en_main; end
  def self.css_lexer_en_main=(arg0); end
  def self.css_lexer_en_predicate; end
  def self.css_lexer_en_predicate=(arg0); end
  def self.css_lexer_en_pseudo_args; end
  def self.css_lexer_en_pseudo_args=(arg0); end
  def self.css_lexer_error; end
  def self.css_lexer_error=(arg0); end
  def self.css_lexer_first_final; end
  def self.css_lexer_first_final=(arg0); end
  def self.css_lexer_start; end
  def self.css_lexer_start=(arg0); end
  def slice_input(start, stop); end
end
class Oga::CSS::Parser < LL::Driver
  def _rule_0(val); end
  def _rule_1(val); end
  def _rule_10(val); end
  def _rule_11(val); end
  def _rule_12(val); end
  def _rule_13(val); end
  def _rule_14(val); end
  def _rule_15(val); end
  def _rule_16(val); end
  def _rule_17(val); end
  def _rule_18(val); end
  def _rule_19(val); end
  def _rule_2(val); end
  def _rule_20(val); end
  def _rule_21(val); end
  def _rule_22(val); end
  def _rule_23(val); end
  def _rule_24(val); end
  def _rule_25(val); end
  def _rule_26(val); end
  def _rule_27(val); end
  def _rule_28(val); end
  def _rule_29(val); end
  def _rule_3(val); end
  def _rule_30(val); end
  def _rule_31(val); end
  def _rule_32(val); end
  def _rule_33(val); end
  def _rule_34(val); end
  def _rule_35(val); end
  def _rule_36(val); end
  def _rule_37(val); end
  def _rule_38(val); end
  def _rule_39(val); end
  def _rule_4(val); end
  def _rule_40(val); end
  def _rule_41(val); end
  def _rule_42(val); end
  def _rule_43(val); end
  def _rule_44(val); end
  def _rule_45(val); end
  def _rule_46(val); end
  def _rule_47(val); end
  def _rule_48(val); end
  def _rule_49(val); end
  def _rule_5(val); end
  def _rule_50(val); end
  def _rule_51(val); end
  def _rule_52(val); end
  def _rule_53(val); end
  def _rule_54(val); end
  def _rule_55(val); end
  def _rule_56(val); end
  def _rule_57(val); end
  def _rule_58(val); end
  def _rule_59(val); end
  def _rule_6(val); end
  def _rule_60(val); end
  def _rule_61(val); end
  def _rule_62(val); end
  def _rule_63(val); end
  def _rule_64(val); end
  def _rule_65(val); end
  def _rule_7(val); end
  def _rule_8(val); end
  def _rule_9(val); end
  def add_child(node, child); end
  def current_element; end
  def each_token; end
  def generate_axis(name, test = nil, predicates = nil, more = nil); end
  def generate_no_siblings(axis, test = nil); end
  def generate_nth_child(count_axis, arg, count_test = nil); end
  def initialize(data); end
  def int_node?(node); end
  def non_positive_number?(node); end
  def on_op_ends_with(attr, value); end
  def on_op_eq(attr, value); end
  def on_op_hyphen_in(attr, value); end
  def on_op_in(attr, value); end
  def on_op_space_in(attr, value); end
  def on_op_starts_with(attr, value); end
  def on_pseudo_class(name, arg = nil); end
  def on_pseudo_class_empty; end
  def on_pseudo_class_first_child; end
  def on_pseudo_class_first_of_type; end
  def on_pseudo_class_last_child; end
  def on_pseudo_class_last_of_type; end
  def on_pseudo_class_not(arg); end
  def on_pseudo_class_nth(arg); end
  def on_pseudo_class_nth_child(arg); end
  def on_pseudo_class_nth_last_child(arg); end
  def on_pseudo_class_nth_last_of_type(arg); end
  def on_pseudo_class_nth_of_type(arg); end
  def on_pseudo_class_only_child; end
  def on_pseudo_class_only_of_type; end
  def on_pseudo_class_root; end
  def on_test(namespace, name); end
  def parse; end
  def reset; end
  def s(type, *children); end
  def self.parse_with_cache(data); end
  def step_comparison(node); end
  def step_modulo_value(step); end
end

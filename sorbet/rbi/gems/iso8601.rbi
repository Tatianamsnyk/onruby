# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/iso8601/all/iso8601.rbi
#
# iso8601-0.9.1
module ISO8601
end
module ISO8601::Errors
end
class ISO8601::Errors::StandardError < StandardError
end
class ISO8601::Errors::UnknownPattern < ISO8601::Errors::StandardError
  def initialize(pattern); end
end
class ISO8601::Errors::InvalidFractions < ISO8601::Errors::StandardError
  def initialize; end
end
class ISO8601::Errors::RangeError < ISO8601::Errors::StandardError
  def initialize(pattern); end
end
class ISO8601::Errors::TypeError < ArgumentError
end
class ISO8601::Errors::IntervalError < ISO8601::Errors::StandardError
end
class ISO8601::Errors::DurationBaseError < ISO8601::Errors::StandardError
  def initialize(duration); end
end
module ISO8601::Atomic
  def <=>(other); end
  def atom; end
  def eql?(other); end
  def hash; end
  def to_f; end
  def to_i; end
  def to_s; end
  def valid_atom?(atom); end
  def valid_base?(base); end
  def value; end
  include Comparable
end
class ISO8601::Years
  def adjusted_factor(atom, base); end
  def factor(base = nil); end
  def initialize(atom); end
  def symbol; end
  def to_seconds(base = nil); end
  def year(atom, base); end
  include ISO8601::Atomic
end
class ISO8601::Months
  def calculation(atom, base); end
  def factor(base = nil); end
  def initialize(atom); end
  def symbol; end
  def to_seconds(base = nil); end
  def zero_calculation(base); end
  include ISO8601::Atomic
end
class ISO8601::Weeks
  def factor; end
  def initialize(atom); end
  def symbol; end
  def to_seconds; end
  include ISO8601::Atomic
end
class ISO8601::Days
  def factor; end
  def initialize(atom); end
  def symbol; end
  def to_seconds; end
  include ISO8601::Atomic
end
class ISO8601::Hours
  def factor; end
  def initialize(atom); end
  def symbol; end
  def to_seconds; end
  include ISO8601::Atomic
end
class ISO8601::Minutes
  def factor; end
  def initialize(atom); end
  def symbol; end
  def to_seconds; end
  include ISO8601::Atomic
end
class ISO8601::Seconds
  def factor; end
  def initialize(atom); end
  def symbol; end
  def to_seconds; end
  include ISO8601::Atomic
end
class ISO8601::Date
  def +(other); end
  def -(other); end
  def ==(other); end
  def atomize(input); end
  def atomize_ordinal(year, day, separator, sign); end
  def atomize_week_date(input, separator, sign); end
  def atoms; end
  def compose(atoms); end
  def day(*args, &block); end
  def eql?(other); end
  def hash; end
  def initialize(input); end
  def month(*args, &block); end
  def parse(string); end
  def parse_date(input); end
  def parse_ordinal(input); end
  def parse_weekdate(input); end
  def separator; end
  def to_a; end
  def to_date(*args, &block); end
  def to_datetime(*args, &block); end
  def to_s(*args, &block); end
  def to_time(*args, &block); end
  def wday(*args, &block); end
  def week; end
  def year(*args, &block); end
  extend Forwardable
end
class ISO8601::Time
  def +(other); end
  def -(other); end
  def ==(other); end
  def atomize(input); end
  def atoms; end
  def compose(atoms, base); end
  def eql?(other); end
  def hash; end
  def hour(*args, &block); end
  def initialize(input, base = nil); end
  def minute(*args, &block); end
  def parse_second(second); end
  def parse_time(time); end
  def parse_timezone(timezone); end
  def require_separator(input); end
  def second; end
  def separator; end
  def to_a; end
  def to_date(*args, &block); end
  def to_datetime(*args, &block); end
  def to_s; end
  def to_time(*args, &block); end
  def valid_zone?(zone, require_separator); end
  def zone(*args, &block); end
  extend Forwardable
end
class ISO8601::DateTime
  def +(other); end
  def -(other); end
  def ==(other); end
  def atoms; end
  def day(*args, &block); end
  def eql?(other); end
  def hash; end
  def hour(*args, &block); end
  def initialize(date_time); end
  def minute(*args, &block); end
  def month(*args, &block); end
  def parse(date_time); end
  def parse_date(input); end
  def parse_time(input); end
  def second; end
  def strftime(*args, &block); end
  def to_a; end
  def to_date(*args, &block); end
  def to_datetime(*args, &block); end
  def to_f; end
  def to_s; end
  def to_time(*args, &block); end
  def valid_representation?(date, time); end
  def valid_separators?(separators); end
  def year(*args, &block); end
  def zone(*args, &block); end
  extend Forwardable
end
class ISO8601::Duration
  def +(other); end
  def -(other); end
  def ==(other); end
  def abs; end
  def atomize(input); end
  def atoms; end
  def compare_bases(other, base); end
  def days; end
  def decompose_atom(value, atom); end
  def eql?(other); end
  def fetch_seconds(other, base = nil); end
  def hash; end
  def hours; end
  def initialize(input); end
  def minutes; end
  def months; end
  def months_to_seconds(base); end
  def parse(input); end
  def parse_tokens(tokens); end
  def pattern; end
  def seconds; end
  def seconds_to_iso(value); end
  def sign; end
  def sign_to_i(sign); end
  def to_date_s(sign, *args); end
  def to_pattern(original); end
  def to_s; end
  def to_seconds(base = nil); end
  def to_time_s(*args); end
  def valid_fractions?(values); end
  def valid_pattern?(components); end
  def validate_base(input); end
  def weeks; end
  def years; end
end
class ISO8601::TimeInterval
  def <=>(other); end
  def disjoint?(other); end
  def empty?; end
  def end_time; end
  def eql?(other); end
  def first; end
  def from_atoms(atoms); end
  def hash; end
  def include?(other); end
  def initialize(input); end
  def intersect?(other); end
  def intersection(other); end
  def last; end
  def length; end
  def limits(atoms); end
  def member?(other); end
  def parse(pattern); end
  def parse_subpattern(pattern); end
  def pattern; end
  def self.from_datetimes(*atoms); end
  def self.from_duration(*atoms); end
  def self.guard_from_datetimes(atoms, message); end
  def self.guard_from_duration(atoms, message); end
  def self.parse(pattern); end
  def self.valid_date_time?(time, message = nil); end
  def size; end
  def sort_pair(a, b); end
  def start_time; end
  def subset?(other); end
  def superset?(other); end
  def to_f; end
  def to_s; end
  def tuple_by_both(atoms); end
  def tuple_by_end(atoms); end
  def tuple_by_start(atoms); end
  def valid_atoms?(atoms); end
  def valid_date_time?(time); end
  include Comparable
end
